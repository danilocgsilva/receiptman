The receipt object contains instructions to build the docker-compose.yml content. The problem is that now my docker-compose.yml needs to be build with a combination of two recipe objects.
The recipe object is responsible to build the docker-compose.yml content. It is an array belonging to the parent class, with protected visibility.
The recipe is also responsible for defining the set of questions necessary for the own configuration. The objective is to configure my docker-compose.yml file to encompass a combination of two services.
To achive this, for example merging the python recipe with one for mysql, might be reasonable run configuration query for both recipes. The problem is that in the final step of writting the file, each recipe is responsible for the docker-compose.yml, among all the other files to accomplish the package recipe. To solve this, it might be necessary to shift the responsability for the content specifically within the docker-compose.yml file away from the recipe itself, and instead assign it to someone who can merge configurations from both recipes. But it could be a problematic because the recipe would still be responsible for generating all other recipe files and putting an exception only in the docker-compose.yml file can be bad for maintainability.
Alternativelly, the recipe class wouldn't need to be responsible for write all recipe files anymore. A new class could take on that responsability. It would read all the configuration made on the recibe object and have the logic the set the files and its contents. Beign its responsability, it could also accept several recipe objects, what would allow for more complex recipes that involves not just the docker-compose.yml file, but also other files.
One thing that is not ideal about the current classes architectures is that they also determines content *outside* of the service. This responsability also makes sense to be assigned to this new class. However, the recipe class would need to expose its contents based on the define configurations.
There's a catch: the recipe classes implements the `getFiles` method, where it returns an array with all files required for the recipe package. For the docker-compose.yml file, it uses the `Symfony\Component\Yaml\Yaml` to read the recipe structure and pour the raw file content. A simpler approach might be to keep the `yamlStructure` inside the receipts, but get rid of the stuff that does not have relationship to the recipe itself, like the `services` sections. Once each recipe is responsible to the whole docker-compose.yml file, realise that the recipe structure are within it, that makes part of recipe responsabilities. But now I need the flexibility the use one `services` section to encompass several *services*, each one coming from different recipes, and it will take place outside the recipe file. But still, some files may be from the recipe responsability. For example, PHP configurations should not the set externally to the recipe. But by the other hand, docker-compose.yml and Dockerfile may be create with the combination data from two different recipes. So the final package recipe may be composed by a combination of *service specific configration file*, which are the recipe responsability, and the *container configuration*, like `Dockerfile` and `docker-compose.yml` that may ne taylored by a mix of configuration of several recipes.

Beign so,

Create a new class, responsible to receive the recipe object, possibly several ones, read its configurations and give the list of objects to be created.
Keep the `yamlStructure` in the recipes. But get rid of sections outside the own service. And set a way to expose the structure to a third service.
The new class may receive the configuration files from the service recipe, meanwhile read other configuration, like reading `yamlStructure` from recipes and process rules that may interact to the configuration from other recipes.
